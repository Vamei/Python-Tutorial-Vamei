#Python进阶04 函数的参数对应

 

我们已经接触过函数(function)的参数(arguments)传递。当时我们根据位置，传递对应的参数。我们将接触更多的参数传递方式。

 

回忆一下位置传递：
```python
def f(a,b,c):
    return a+b+c

print(f(1,2,3))
```
在调用f时，1，2，3根据位置分别传递给了a,b,c。

 

##关键字传递

有些情况下，用位置传递会感觉比较死板。关键字(keyword)传递是根据每个参数的名字传递参数。关键字并不用遵守位置的对应关系。依然沿用上面f的定义，更改调用方式：
```python
print(f(c=3,b=2,a=1))
``` 

关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：
```python
print(f(1,c=3,b=2))
``` 

##参数默认值

在定义函数的时候，使用形如a=19的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。
```python
def f(a,b,c=10):
    return a+b+c

print(f(3,2))
print(f(3,2,1))
```
在第一次调用函数f时， 我们并没有足够的值，c没有被赋值，c将使用默认值10.

第二次调用函数的时候，c被赋值为1，不再使用默认值。

 

##包裹传递

在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。

 

下面是包裹位置传递的例子：
```python
def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3)
```
两次调用，尽管参数个数不同，都基于同一个func定义。在func的参数表中，所有的参数被name收集，根据位置合并成一个元组(tuple)，这就是包裹位置传递。

为了提醒Python参数，name是包裹位置传递所用的元组名，在定义func时，在name前加*号。

 

下面是包裹关键字传递的例子：
``python
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)
func(m=2,n=1,c=11)
```
与上面一个例子类似，dict是一个字典，收集所有的关键字，传递给函数func。为了提醒Python，参数dict是包裹关键字传递所用的字典，在dict前加**。

包裹传递的关键在于定义函数时，在相应元组或字典前加*或**。

 

##解包裹

*和**，也可以在调用的时候使用，即解包裹(unpacking), 下面为例：
```python
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args)
```
在这个例子中，所谓的解包裹，就是在传递tuple时，让tuple的每一个元素对应一个位置参数。在调用func时使用*，是为了提醒Python：我想要把args拆成分散的三个元素，分别传递给a,b,c。（设想一下在调用func时，args前面没有*会是什么后果？）

 

相应的，也存在对词典的解包裹，使用相同的func定义，然后：
```python
dict = {'a':1,'b':2,'c':3}
func(**dict)
```
在传递词典dict时，让词典的每个键值对作为一个关键字传递给func。

 

##混合

在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是，先位置，再关键字，再包裹位置，再包裹关键字，并且根据上面所说的原理细细分辨。

 

注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。



##总结

关键字，默认值，

包裹位置，包裹关键字

解包裹
