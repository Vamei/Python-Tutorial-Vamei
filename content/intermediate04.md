#Python进阶04 函数的参数对应

 

我们已经接触过函数(function)的参数(arguments)传递。当时我们根据位置，传递对应的参数。我们将接触更多的参数传递方式。

 

回忆一下位置传递：
```python
def f(a,b,c):
    return a+b+c

print(f(1,2,3))
```
在调用`f`时，`1`，`2`，`3`根据位置分别传递给了`a`,`b`,`c`。

 

##关键字传递

有些情况下，用位置传递会感觉比较死板。关键字(keyword)传递是根据每个参数的名字传递参数。关键字并不用遵守位置的对应关系。依然沿用上面`f`的定义，更改调用方式：
```python
print(f(c=3,b=2,a=1))
``` 

关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：
```python
print(f(1,c=3,b=2))
``` 

##参数默认值

在定义函数的时候，使用形如`a=19`的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值。
```python
def f(a,b,c=10):
    return a+b+c

print(f(3,2))
print(f(3,2,1))
```
在第一次调用函数f时， 我们并没有足够的值，`c`没有被赋值，`c`将使用默认值`10`.

第二次调用函数的时候，`c`被赋值为`1`，不再使用默认值。

 

##包裹传递

在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用。

 

下面是包裹位置传递的例子：
```python
def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3)
```
两次调用，尽管参数个数不同，都基于同一个`func`定义。在`func`的参数表中，所有的参数被`name`收集，根据位置合并成一个元组(`tuple`)，这就是包裹位置传递。

为了提醒Python参数，`name`是包裹位置传递所用的元组名，在定义`func`时，在`name`前加`*`号。

 

下面是包裹关键字传递的例子：
``python
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)
func(m=2,n=1,c=11)
```
与上面一个例子类似，`dict`是一个字典，收集所有的关键字，传递给函数`func`。为了提醒Python，参数`dict`是包裹关键字传递所用的字典，在`dict`前加`**`。

包裹传递的关键在于定义函数时，在相应元组或字典前加`*`或`**`。

 

##解包裹

`*`和`**`，也可以在调用的时候使用，即解包裹(unpacking), 下面为例：
```python
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args)
```
在这个例子中，所谓的解包裹，就是在传递`tuple`时，让`tuple`的每一个元素对应一个位置参数。在调用`func`时使用`*`，是为了提醒Python：我想要把`args`拆成分散的三个元素，分别传递给`a`,`b`,`c`。（设想一下在调用`func`时，`args`前面没有`*`会是什么后果？）

 

相应的，也存在对词典的解包裹，使用相同的`func`定义，然后：
```python
dict = {'a':1,'b':2,'c':3}
func(**dict)
```
在传递词典`dict`时，让词典的每个键值对作为一个关键字传递给`func`。

 

##混合

在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是，先位置，再关键字，再包裹位置，再包裹关键字，并且根据上面所说的原理细细分辨。

 

注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。



##总结

关键字，默认值，

包裹位置，包裹关键字

解包裹
