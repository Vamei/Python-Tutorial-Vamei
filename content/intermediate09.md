#Python进阶09 动态类型


 

动态类型(dynamic typing)是Python另一个重要的核心概念。我们之前说过，Python的变量(variable)不需要声明，而在赋值时，变量可以重新赋值为任意值。这些都与动态类型的概念相关。

 

##动态类型

在我们接触的对象中，有一类特殊的对象，是用于存储数据的。常见的该类对象包括各种数字，字符串，表，词典。在C语言中，我们称这样一些数据结构为变量。而在Python中，这些是对象。

对象是储存在内存中的实体。但我们并不能直接接触到该对象。我们在程序中写的对象名，只是指向这一对象的引用(reference)。

 

引用和对象分离，是动态类型的核心。引用可以随时指向一个新的对象：
```python
a = 3
a = 'at'
```
第一个语句中，3是储存在内存中的一个整数对象。通过赋值，引用a指向对象3。

第二个语句中，内存中建立对象`'at'`，是一个字符串(string)。引用`a`指向了`'at'`。此时，对象`3`不再有引用指向它。Python会自动将没有引用指向的对象销毁(destruct)，释放相应内存。

(对于小的整数和短字符串，Python会缓存这些对象，而不是频繁的建立和销毁。)

 
```python
a = 5
b = a
a = a + 2
```
再看这个例子。通过前两个句子，我们让`a`,`b`指向同一个整数对象`5`(`b = a`的含义是让引用b指向引用`a`所指的那一个对象)。但第三个句子实际上对引用`a`重新赋值，让`a`指向一个新的对象`7`。此时`a`,`b`分别指向不同的对象。我们看到，即使是多个引用指向同一个对象，如果一个引用值发生变化，那么实际上是让这个引用指向一个新的引用，并不影响其他的引用的指向。从效果上看，就是各个引用各自独立，互不影响。

 

其它数据对象也是如此:
```python
L1 = [1,2,3]
L2 = L1
L1 = 1
```

但注意以下情况
```python
L1 = [1,2,3]
L2 = L1
L1[0] = 10
print L2
```
在该情况下，我们不再对`L1`这一引用赋值，而是对`L1`所指向的表的元素赋值。结果是，`L2`也同时发生变化。

原因何在呢？因为`L1`，`L2`的指向没有发生变化，依然指向那个表。表实际上是包含了多个引用的对象（每个引用是一个元素，比如`L1[0]`，`L1[1]`..., 每个引用指向一个对象，比如`1`,`2`,`3`), 。而`L1[0] = 10`这一赋值操作，并不是改变`L1`的指向，而是对`L1[0]`, 也就是表对象的一部份(一个元素)，进行操作，所以所有指向该对象的引用都受到影响。

（与之形成对比的是，我们之前的赋值操作都没有对对象自身发生作用，只是改变引用指向。）

 

列表可以通过引用其元素，改变对象自身(in-place change)。这种对象类型，称为可变数据对象(mutable object)，词典也是这样的数据类型。

而像之前的数字和字符串，不能改变对象本身，只能改变引用的指向，称为不可变数据对象(immutable object)。

我们之前学的元组(`tuple`)，尽管可以调用引用元素，但不可以赋值，因此不能改变对象自身，所以也算是immutable object.

 

##从动态类型看函数的参数传递

函数的参数传递，本质上传递的是引用。比如说：

```python
def f(x):
    x = 100
    print x

a = 1
f(a)
print a
```

参数x是一个新的引用，指向a所指的对象。如果参数是不可变(immutable)的对象，`a`和`x`引用之间相互独立。对参数`x`的操作不会影响引用`a`。这样的传递类似于C语言中的值传递。

 

如果传递的是可变(mutable)的对象，那么改变函数参数，有可能改变原对象。所有指向原对象的引用都会受影响，编程的时候要对此问题留心。比如说：

```python
def f(x):
    x[0] = 100
    print x

a = [1,2,3]
f(a)
print a
```
 

动态类型是Python的核心机制之一。可以在应用中慢慢熟悉。

 

##总结

引用和对象的分离，对象是内存中储存数据的实体，引用指向对象。

可变对象，不可变对象

函数值传递
